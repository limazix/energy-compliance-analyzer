
name: Deploy to Firebase

on:
  push:
    branches:
      - main # Ou a branch que você usa para produção

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write' # Necessário para autenticação com Google Cloud via Workload Identity Federation

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18' # Use a versão do Node.js compatível com seu projeto

      - name: Install dependencies
        run: npm ci # 'ci' é geralmente mais rápido e seguro para CI do que 'install'

      - name: Build Next.js application
        run: npm run build
        env:
          # Se suas build precisa de variáveis de ambiente, defina-as aqui
          # Exemplo: NEXT_PUBLIC_FIREBASE_API_KEY: ${{ secrets.YOUR_FIREBASE_API_KEY_SECRET }}
          # No entanto, para as chaves do Firebase usadas no cliente, elas já estão no next.config.js
          # e devem ser populadas no ambiente de build do App Hosting.
          # Para o build local do Next.js, ele pegaria do .env se presente, mas no CI não haverá .env.
          # As variáveis NEXT_PUBLIC_ já são lidas do ambiente no next.config.ts.
          # O importante é que NEXT_PUBLIC_GEMINI_API_KEY esteja disponível se o build o exigir.
          # Para este projeto, as variáveis NEXT_PUBLIC_ são usadas principalmente no runtime do cliente.
          # O build em si pode não precisar delas, a menos que você tenha alguma lógica de build que as use.
          NEXT_PUBLIC_FIREBASE_API_KEY: "dummy" # Placeholder se o build reclamar, mas o runtime usará as do App Hosting
          NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: "dummy"
          NEXT_PUBLIC_FIREBASE_PROJECT_ID: "electric-magnitudes-analizer" # Importante que o build saiba o projeto
          NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: "dummy"
          NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: "dummy"
          NEXT_PUBLIC_FIREBASE_APP_ID: "dummy"
          NEXT_PUBLIC_GEMINI_API_KEY: "dummy" # Placeholder para build

      - name: Install Firebase CLI
        run: npm install -g firebase-tools

      - name: Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/${{ secrets.GCP_WORKLOAD_IDENTITY_POOL_ID }}/providers/${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER_ID }}' # Ex: projects/123456789/locations/global/workloadIdentityPools/my-pool/providers/my-provider
          service_account: '${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}' # Ex: firebase-deploy-sa@<PROJECT_ID>.iam.gserviceaccount.com
          # Se não usar Workload Identity Federation, pode autenticar com a chave da conta de serviço JSON:
          # credentials_json: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_ELECTRIC_MAGNITUDES_ANALIZER }}'

      # Se autenticou com a chave JSON, pode pular o passo acima e usar FIREBASE_TOKEN
      # - name: Authenticate Firebase (Service Account Key)
      #   run: echo "FIREBASE_TOKEN=$(firebase login:ci --no-localhost --token "${{ secrets.FIREBASE_SERVICE_ACCOUNT_ELECTRIC_MAGNITUDES_ANALIZER }}" --project electric-magnitudes-analizer --interactive)" >> $GITHUB_ENV
      #   # Este método com login:ci pode ser problemático. Workload Identity Federation é o preferido.

      - name: Deploy to Firebase App Hosting
        run: |
          firebase apphosting:backends:deploy YOUR_APP_HOSTING_BACKEND_ID \
            --project electric-magnitudes-analizer \
            --non-interactive
        env:
          # Se usando FIREBASE_TOKEN após login:ci (método menos preferido)
          # FIREBASE_TOKEN: ${{ env.FIREBASE_TOKEN }}
          # Para Workload Identity Federation, a autenticação gcloud já deve funcionar para Firebase.
          GOOGLE_APPLICATION_CREDENTIALS: ${{ steps.auth.outputs.credentials_path }} # Se 'google-github-actions/auth' foi usado com service_account (não workload identity provider direto)

      - name: Deploy Firebase Rules
        run: |
          firebase deploy --only firestore:rules,storage:rules \
            --project electric-magnitudes-analizer \
            --non-interactive
        env:
          # FIREBASE_TOKEN: ${{ env.FIREBASE_TOKEN }} # Se usando token
          GOOGLE_APPLICATION_CREDENTIALS: ${{ steps.auth.outputs.credentials_path }} # Se 'google-github-actions/auth' foi usado com service_account

    # Informações sobre segredos que precisam ser configurados no GitHub:
    #
    # Para Workload Identity Federation (método recomendado):
    # 1. GCP_PROJECT_NUMBER: O número do seu projeto Google Cloud (ex: 1234567890).
    # 2. GCP_WORKLOAD_IDENTITY_POOL_ID: O ID do seu Workload Identity Pool.
    # 3. GCP_WORKLOAD_IDENTITY_PROVIDER_ID: O ID do seu Workload Identity Provider.
    # 4. GCP_SERVICE_ACCOUNT_EMAIL: O email da conta de serviço do GCP que o GitHub Actions usará.
    #    Esta conta de serviço precisa ter as permissões:
    #    - Firebase App Hosting Admin (roles/firebaseapphosting.admin)
    #    - Firebase Rules System (roles/firebaserules.system)
    #    - Service Account Token Creator (roles/iam.serviceAccountTokenCreator) - para impersonate
    #
    # Para autenticação com chave de conta de serviço JSON (método alternativo):
    # 1. FIREBASE_SERVICE_ACCOUNT_ELECTRIC_MAGNITUDES_ANALIZER: O conteúdo JSON da chave da sua conta de serviço Firebase.
    #    A conta de serviço deve ter as permissões:
    #    - Firebase App Hosting Admin
    #    - Firebase Rules System
    #
    # E você precisará substituir 'YOUR_APP_HOSTING_BACKEND_ID' pelo ID real do seu backend do App Hosting.
